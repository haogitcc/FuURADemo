<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Mercury C API: ltkc_win32/inc/ltkc_connection.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ltkc_win32/inc/ltkc_connection.h File Reference</h1>
<p>Types and function prototypes for handling two-way LLRP message traffic.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_l_l_r_p___s_connection.html">LLRP_SConnection</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure of an LLRP connection instance.  <a href="struct_l_l_r_p___s_connection.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_l_l_r_p___s_connection.html">LLRP_tSConnection</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ltkc__connection_8h.html#aecdb8ca9463a41bd5474a8de56f23032">LLRP_Conn_construct</a> (const LLRP_tSTypeRegistry *pTypeRegistry, unsigned int nBufferSize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a new LLRP connection instance.  <a href="#aecdb8ca9463a41bd5474a8de56f23032"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ltkc__connection_8h.html#a426c367efbba2dd36cad167f62b2f58c">LLRP_Conn_destruct</a> (<a class="el" href="struct_l_l_r_p___s_connection.html">LLRP_tSConnection</a> *pConn)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destruct a LLRP connection instance.  <a href="#a426c367efbba2dd36cad167f62b2f58c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ltkc__connection_8h.html#a34839b3b0f75f70e4d987fc8682d928a">LLRP_Conn_openConnectionToReader</a> (<a class="el" href="struct_l_l_r_p___s_connection.html">LLRP_tSConnection</a> *pConn, const char *pReaderHostName)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Open the connection to the reader.  <a href="#a34839b3b0f75f70e4d987fc8682d928a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ltkc__connection_8h.html#afe2f6eb83a91dc4a15454f43c5c67615">LLRP_Conn_closeConnectionToReader</a> (<a class="el" href="struct_l_l_r_p___s_connection.html">LLRP_tSConnection</a> *pConn)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Close connection to reader, allow reuse of instance.  <a href="#afe2f6eb83a91dc4a15454f43c5c67615"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ltkc__connection_8h.html#aab6814387e9ffa71cbd22780ce704fa3">LLRP_Conn_getConnectError</a> (<a class="el" href="struct_l_l_r_p___s_connection.html">LLRP_tSConnection</a> *pConn)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the string that explains LLRP_Conn_openReaderConnection() error.  <a href="#aab6814387e9ffa71cbd22780ce704fa3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LLRP_tSMessage *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ltkc__connection_8h.html#a03246bb08c75ae024fd977f9ddbb9d43">LLRP_Conn_transact</a> (<a class="el" href="struct_l_l_r_p___s_connection.html">LLRP_tSConnection</a> *pConn, LLRP_tSMessage *pSendMessage, int nMaxMS)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transact a LLRP request and response to a connection.  <a href="#a03246bb08c75ae024fd977f9ddbb9d43"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const LLRP_tSErrorDetails *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ltkc__connection_8h.html#a3348d0ef225ff879074de2ebba0e81cd">LLRP_Conn_getTransactError</a> (<a class="el" href="struct_l_l_r_p___s_connection.html">LLRP_tSConnection</a> *pConn)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the details that explains <a class="el" href="ltkc__connection_8h.html#a03246bb08c75ae024fd977f9ddbb9d43" title="Transact a LLRP request and response to a connection.">LLRP_Conn_transact()</a> error.  <a href="#a3348d0ef225ff879074de2ebba0e81cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LLRP_tResultCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ltkc__connection_8h.html#a14735b5cf215e13e1559dc33938c02d3">LLRP_Conn_sendMessage</a> (<a class="el" href="struct_l_l_r_p___s_connection.html">LLRP_tSConnection</a> *pConn, LLRP_tSMessage *pMessage)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a LLRP message to a connection.  <a href="#a14735b5cf215e13e1559dc33938c02d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const LLRP_tSErrorDetails *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ltkc__connection_8h.html#a76880b0ee764f316b470c9e6d97ec4be">LLRP_Conn_getSendError</a> (<a class="el" href="struct_l_l_r_p___s_connection.html">LLRP_tSConnection</a> *pConn)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the details that explains <a class="el" href="ltkc__connection_8h.html#a14735b5cf215e13e1559dc33938c02d3" title="Send a LLRP message to a connection.">LLRP_Conn_sendMessage()</a> error.  <a href="#a76880b0ee764f316b470c9e6d97ec4be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LLRP_tSMessage *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ltkc__connection_8h.html#a2f0b8f7454deb9d50204d305f6113442">LLRP_Conn_recvMessage</a> (<a class="el" href="struct_l_l_r_p___s_connection.html">LLRP_tSConnection</a> *pConn, int nMaxMS)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive a message from a connection.  <a href="#a2f0b8f7454deb9d50204d305f6113442"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">LLRP_tSMessage *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ltkc__connection_8h.html#a66aa1134e8b764464545837dd002f98e">LLRP_Conn_recvResponse</a> (<a class="el" href="struct_l_l_r_p___s_connection.html">LLRP_tSConnection</a> *pConn, int nMaxMS, const LLRP_tSTypeDescriptor *pResponseType, llrp_u32_t ResponseMessageID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive a specific message from a connection.  <a href="#a66aa1134e8b764464545837dd002f98e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const LLRP_tSErrorDetails *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ltkc__connection_8h.html#a600cc168ff488023c4d690031405ae16">LLRP_Conn_getRecvError</a> (<a class="el" href="struct_l_l_r_p___s_connection.html">LLRP_tSConnection</a> *pConn)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the details that explains <a class="el" href="ltkc__connection_8h.html#a2f0b8f7454deb9d50204d305f6113442" title="Receive a message from a connection.">LLRP_Conn_recvMessage()</a> or <a class="el" href="ltkc__connection_8h.html#a66aa1134e8b764464545837dd002f98e" title="Receive a specific message from a connection.">LLRP_Conn_recvResponse()</a> error.  <a href="#a600cc168ff488023c4d690031405ae16"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Types and function prototypes for handling two-way LLRP message traffic. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="afe2f6eb83a91dc4a15454f43c5c67615"></a><!-- doxytag: member="ltkc_connection.h::LLRP_Conn_closeConnectionToReader" ref="afe2f6eb83a91dc4a15454f43c5c67615" args="(LLRP_tSConnection *pConn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LLRP_Conn_closeConnectionToReader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_l_r_p___s_connection.html">LLRP_tSConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>pConn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close connection to reader, allow reuse of instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pConn</em>&nbsp;</td><td>Pointer to the connection instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>==0 Connected OK, ready for business !=0 Error, check getConnectError() for reason </dd></dl>

</div>
</div>
<a class="anchor" id="aecdb8ca9463a41bd5474a8de56f23032"></a><!-- doxytag: member="ltkc_connection.h::LLRP_Conn_construct" ref="aecdb8ca9463a41bd5474a8de56f23032" args="(const LLRP_tSTypeRegistry *pTypeRegistry, unsigned int nBufferSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_l_l_r_p___s_connection.html">LLRP_tSConnection</a>* LLRP_Conn_construct </td>
          <td>(</td>
          <td class="paramtype">const LLRP_tSTypeRegistry *&nbsp;</td>
          <td class="paramname"> <em>pTypeRegistry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>nBufferSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct a new LLRP connection instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pTypeRegistry</em>&nbsp;</td><td>The LLRP registry of known message/parameter types. Includes standard and custom. Used during decode. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nBufferSize</em>&nbsp;</td><td>Size of each the receive and send buffers. Use size larger than the largest frame you expect. 0 selects a default value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>!=NULL Pointer to connection instance ==NULL Error, always an allocation failure most likely nBufferSize is weird </dd></dl>

</div>
</div>
<a class="anchor" id="a426c367efbba2dd36cad167f62b2f58c"></a><!-- doxytag: member="ltkc_connection.h::LLRP_Conn_destruct" ref="a426c367efbba2dd36cad167f62b2f58c" args="(LLRP_tSConnection *pConn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LLRP_Conn_destruct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_l_r_p___s_connection.html">LLRP_tSConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>pConn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destruct a LLRP connection instance. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pConn</em>&nbsp;</td><td>Pointer to the connection instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="aab6814387e9ffa71cbd22780ce704fa3"></a><!-- doxytag: member="ltkc_connection.h::LLRP_Conn_getConnectError" ref="aab6814387e9ffa71cbd22780ce704fa3" args="(LLRP_tSConnection *pConn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* LLRP_Conn_getConnectError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_l_r_p___s_connection.html">LLRP_tSConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>pConn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the string that explains LLRP_Conn_openReaderConnection() error. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pConn</em>&nbsp;</td><td>Pointer to the connection instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>==NULL No error !=NULL Short string description of error </dd></dl>

</div>
</div>
<a class="anchor" id="a600cc168ff488023c4d690031405ae16"></a><!-- doxytag: member="ltkc_connection.h::LLRP_Conn_getRecvError" ref="a600cc168ff488023c4d690031405ae16" args="(LLRP_tSConnection *pConn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const LLRP_tSErrorDetails* LLRP_Conn_getRecvError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_l_r_p___s_connection.html">LLRP_tSConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>pConn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the details that explains <a class="el" href="ltkc__connection_8h.html#a2f0b8f7454deb9d50204d305f6113442" title="Receive a message from a connection.">LLRP_Conn_recvMessage()</a> or <a class="el" href="ltkc__connection_8h.html#a66aa1134e8b764464545837dd002f98e" title="Receive a specific message from a connection.">LLRP_Conn_recvResponse()</a> error. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pConn</em>&nbsp;</td><td>Pointer to the connection instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to const error details </dd></dl>

</div>
</div>
<a class="anchor" id="a76880b0ee764f316b470c9e6d97ec4be"></a><!-- doxytag: member="ltkc_connection.h::LLRP_Conn_getSendError" ref="a76880b0ee764f316b470c9e6d97ec4be" args="(LLRP_tSConnection *pConn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const LLRP_tSErrorDetails* LLRP_Conn_getSendError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_l_r_p___s_connection.html">LLRP_tSConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>pConn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the details that explains <a class="el" href="ltkc__connection_8h.html#a14735b5cf215e13e1559dc33938c02d3" title="Send a LLRP message to a connection.">LLRP_Conn_sendMessage()</a> error. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pConn</em>&nbsp;</td><td>Pointer to the connection instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to const error details </dd></dl>

</div>
</div>
<a class="anchor" id="a3348d0ef225ff879074de2ebba0e81cd"></a><!-- doxytag: member="ltkc_connection.h::LLRP_Conn_getTransactError" ref="a3348d0ef225ff879074de2ebba0e81cd" args="(LLRP_tSConnection *pConn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const LLRP_tSErrorDetails* LLRP_Conn_getTransactError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_l_r_p___s_connection.html">LLRP_tSConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>pConn</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the details that explains <a class="el" href="ltkc__connection_8h.html#a03246bb08c75ae024fd977f9ddbb9d43" title="Transact a LLRP request and response to a connection.">LLRP_Conn_transact()</a> error. </p>
<p>This is not 100% reliable. It looks at the send error and if that seems OK it uses the recv error. Uses of <a class="el" href="ltkc__connection_8h.html#a14735b5cf215e13e1559dc33938c02d3" title="Send a LLRP message to a connection.">LLRP_Conn_sendMessage()</a>, <a class="el" href="ltkc__connection_8h.html#a2f0b8f7454deb9d50204d305f6113442" title="Receive a message from a connection.">LLRP_Conn_recvMessage()</a> or LLRP_CONN_recvResponse() since <a class="el" href="ltkc__connection_8h.html#a03246bb08c75ae024fd977f9ddbb9d43" title="Transact a LLRP request and response to a connection.">LLRP_Conn_transact()</a> will distort the error.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to const error details </dd></dl>

</div>
</div>
<a class="anchor" id="a34839b3b0f75f70e4d987fc8682d928a"></a><!-- doxytag: member="ltkc_connection.h::LLRP_Conn_openConnectionToReader" ref="a34839b3b0f75f70e4d987fc8682d928a" args="(LLRP_tSConnection *pConn, const char *pReaderHostName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int LLRP_Conn_openConnectionToReader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_l_r_p___s_connection.html">LLRP_tSConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>pConn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pReaderHostName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open the connection to the reader. </p>
<p>The steps:</p>
<ul>
<li>Look up the host name</li>
<li>Create a socket</li>
<li>Connect to the host address</li>
<li>Condition the socket (set options)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pConn</em>&nbsp;</td><td>Pointer to the connection instance. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pReaderHostName</em>&nbsp;</td><td>String containing the reader host name</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>==0 Connected OK, ready for business !=0 Error, check <a class="el" href="ltkc__connection_8h.html#aab6814387e9ffa71cbd22780ce704fa3" title="Get the string that explains LLRP_Conn_openReaderConnection() error.">LLRP_Conn_getConnectError()</a> for reason </dd></dl>

</div>
</div>
<a class="anchor" id="a2f0b8f7454deb9d50204d305f6113442"></a><!-- doxytag: member="ltkc_connection.h::LLRP_Conn_recvMessage" ref="a2f0b8f7454deb9d50204d305f6113442" args="(LLRP_tSConnection *pConn, int nMaxMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LLRP_tSMessage* LLRP_Conn_recvMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_l_r_p___s_connection.html">LLRP_tSConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>pConn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nMaxMS</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receive a message from a connection. </p>
<p>The message could have already arrived and be pending on the input queue.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pConn</em>&nbsp;</td><td>Pointer to the connection instance. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nMaxMS</em>&nbsp;</td><td>-1 =&gt; block indefinitely 0 =&gt; just peek at input queue and socket queue, return immediately no matter what &gt;0 =&gt; ms to await complete frame</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>==NULL No message available per parameters. Check LLRP_Conn_getRecvErrot() for why !=NULL Input message </dd></dl>

</div>
</div>
<a class="anchor" id="a66aa1134e8b764464545837dd002f98e"></a><!-- doxytag: member="ltkc_connection.h::LLRP_Conn_recvResponse" ref="a66aa1134e8b764464545837dd002f98e" args="(LLRP_tSConnection *pConn, int nMaxMS, const LLRP_tSTypeDescriptor *pResponseType, llrp_u32_t ResponseMessageID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LLRP_tSMessage* LLRP_Conn_recvResponse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_l_r_p___s_connection.html">LLRP_tSConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>pConn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nMaxMS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LLRP_tSTypeDescriptor *&nbsp;</td>
          <td class="paramname"> <em>pResponseType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llrp_u32_t&nbsp;</td>
          <td class="paramname"> <em>ResponseMessageID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receive a specific message from a connection. </p>
<p>The message is identified by type and message ID.</p>
<p>This is used to receive a response to a request, but could be used for other things, too. A message matches and is returned if the type matches AND if the message ID matches. Either or both can be wildcards.</p>
<p>The sought message could have already arrived and be pending on the input queue. While we are looking for the response notifications might arrive. They are held in the input queue while we continue to look for the sought message.</p>
<p>About timeLimit.... The timeLimit is the last time() we'll try to receive the sought message and prevents "spinning". It is conceivable that a steady stream of messages other than the one sought could arrive, and the time between those messages could be smaller the nMaxMS. When that happens, recvAdvance() would not time out during its poll/select. It could "spin". The time out must be detected by other means and that's the purpose of timeLimit.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pConn</em>&nbsp;</td><td>Pointer to the connection instance. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nMaxMS</em>&nbsp;</td><td>-1 =&gt; block indefinitely 0 =&gt; just peek at input queue and socket queue, return immediately no matter what &gt;0 =&gt; ms to await complete frame </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pResponseType</em>&nbsp;</td><td>The type descriptor of the sought or NULL to match all messages. If not NULL, ERROR_MESSAGE will also match. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ResponseMessageID</em>&nbsp;</td><td>The MessageID of sought message or 0 to match all messages.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>==NULL No message available per parameters. Check LLRP_Conn_getRecvErrot() for why !=NULL Input message </dd></dl>

</div>
</div>
<a class="anchor" id="a14735b5cf215e13e1559dc33938c02d3"></a><!-- doxytag: member="ltkc_connection.h::LLRP_Conn_sendMessage" ref="a14735b5cf215e13e1559dc33938c02d3" args="(LLRP_tSConnection *pConn, LLRP_tSMessage *pMessage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LLRP_tResultCode LLRP_Conn_sendMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_l_r_p___s_connection.html">LLRP_tSConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>pConn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LLRP_tSMessage *&nbsp;</td>
          <td class="paramname"> <em>pMessage</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send a LLRP message to a connection. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pConn</em>&nbsp;</td><td>Pointer to the connection instance. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pMessage</em>&nbsp;</td><td>Pointer to the LLRP message to send.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>LLRP_RC_OK Frame sent LLRP_RC_SendIOError I/O error in write(). Probably means fd is bad. LLRP_RC_... Encoder error. Check <a class="el" href="ltkc__connection_8h.html#a76880b0ee764f316b470c9e6d97ec4be" title="Get the details that explains LLRP_Conn_sendMessage() error.">LLRP_Conn_getSendError()</a> for why. </dd></dl>

</div>
</div>
<a class="anchor" id="a03246bb08c75ae024fd977f9ddbb9d43"></a><!-- doxytag: member="ltkc_connection.h::LLRP_Conn_transact" ref="a03246bb08c75ae024fd977f9ddbb9d43" args="(LLRP_tSConnection *pConn, LLRP_tSMessage *pSendMessage, int nMaxMS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LLRP_tSMessage* LLRP_Conn_transact </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_l_l_r_p___s_connection.html">LLRP_tSConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>pConn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LLRP_tSMessage *&nbsp;</td>
          <td class="paramname"> <em>pSendMessage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nMaxMS</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transact a LLRP request and response to a connection. </p>
<p>This is a combination of <a class="el" href="ltkc__connection_8h.html#a14735b5cf215e13e1559dc33938c02d3" title="Send a LLRP message to a connection.">LLRP_Conn_sendMessage()</a> and <a class="el" href="ltkc__connection_8h.html#a66aa1134e8b764464545837dd002f98e" title="Receive a specific message from a connection.">LLRP_Conn_recvResponse()</a>. The MessageID is taken from the outgoing messages. It's best to not use MessageID 0. The expected response type is also taken from the outgoing message. ERROR_MESSAGE is also deemed a response;</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pConn</em>&nbsp;</td><td>Pointer to the connection instance. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pSendMessage</em>&nbsp;</td><td>Pointer to the LLRP message to send. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nMaxMS</em>&nbsp;</td><td>-1 =&gt; block indefinitely 0 =&gt; just peek at input queue and socket queue, return immediately no matter what &gt;0 =&gt; ms to await complete frame</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>==NULL Something failed. Use <a class="el" href="ltkc__connection_8h.html#a3348d0ef225ff879074de2ebba0e81cd" title="Get the details that explains LLRP_Conn_transact() error.">LLRP_Conn_getTransactError()</a> for best guess at what went wrong. !=NULL Response message </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Wed Aug 7 04:08:19 2019 for Mercury C API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
